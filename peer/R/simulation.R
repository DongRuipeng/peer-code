#' estimation error
#' @param C true coefficient 
#' @param Chat estimated coefficient 
#' @return estimation error
#' @export
est.err <- function(C, Chat) {
  p <- nrow(C)
  q <- ncol(C)
  err <- (norm(C - Chat, "F") ^ 2 / (p * q)) * 1000
  return(err)
}

#' prediction error 
#' @param X predictors matrix 
#' @param C true coeffiecient 
#' @param Chat estimated coefficient 
#' @return prediction error
#' @export
pred.err <- function(X, C, Chat) {
  p <- nrow(C)
  n <- nrow(X)
  q <- ncol(C)
  err <- (norm(X %*% C - X %*% Chat, "F") ^ 2 / (n * q))
  return(err)
}

#' FDR and FNR 
#' @param U left singular vectors 
#' @param Uhat estimated left singular vectors
#' @param dhat estimated singualr values 
#' @return 
#'  \item{rate}{consisting FDR and FNR}
#' @export
frate <- function(U, Uhat, dhat) {
  p <- nrow(U)
  r <- ncol(U)
  #if did't find out all eigenvalues, use 0 to append
  rhat <- ncol(Uhat)
  if (is.null(rhat)) { rhat <- 1; dhat <- rep(0, r) }
  if (rhat < r) {
    append <- r - rhat
    for (k in 1:append) {
      dhat[rhat + k] <- 0
      Uhat <- cbind(Uhat, rep(0, p))
    }
  }
  #sort d with decreasing order to calculate numerator
  ind <- sort(dhat, decreasing = TRUE, index.return = TRUE)$ix
  fpv <- fnv <- rep(0, r)
  for (i in 1:r) {
    fpv[i] <- sum((U[, i] == 0) & (Uhat[, ind[i]] != 0))
    fnv[i] <- sum((U[, i] != 0) & (Uhat[, ind[i]] == 0))
  }
  fp <- sum(fpv)
  fn <- sum(fnv)
  neg <- sum(U == 0)
  pos <- sum(U != 0)
  fprate <- fp / neg * 100
  fnrate <- fn / pos * 100
  return(list(fprate = fprate, fnrate = fnrate))
}


#' generate a list consisting simulation setup 
#' @param n number of observations
#' @param p dimension of predictor vector
#' @param q dimension of reponse vector 
#' @param nrank rank of true coefficient 
#' @param s sparsity of left singular vectors
#' @param snr singnal to noise rate 
#' @param mrank maximum rank for first step 
#' @param miss missing rate of Y
#' @return 
#'  \item{control}{a list consisting simulation setup}
#' @export
sim.control <- function(n = 200, p = 400, q = 100, nrank = 3, s = 10, snr = 0.5, mrank = 10, miss = 0) {
  return(list(n = n, p = p, q = q, nrank = nrank, s = s,
  snr = snr, mrank = mrank, miss = miss))
}

#' generate result table with RRR, SRRR, SEED, PEER, which
#' includes ErC, ErXC, FPR, FNR and time. 
#' @param control a list consists simlation setting, which can be generated by sim.control() function
#' @return \item{table}{result table with RRR, SRRR, SEED, PEER, which includes ErC, ErXC, FPR, FNR and time.}
#' @export
#' @importFrom rrpack mrrr
#' @importFrom secure secure.path
#' @importFrom rrpack srrr
sim.table <- function(control = control) {
  n <- control$n
  p <- control$p
  q <- control$q
  nrank <- control$nrank
  mrank <- control$mrank
  s <- control$s
  miss <- control$miss
  snr <- control$snr

  sim.data <- sim.setup(n, p, q, nrank, s, snr, miss)
  X <- sim.data$X
  Y <- sim.data$Y
  U <- sim.data$U
  V <- sim.data$V
  d <- sim.data$d
  C <- sim.data$C

  erank <- est.rank(Y, mrank)

  mrrr.fit <- srrr.fit <- seed.fit <- secure.fit <- peer.fit <- data.frame(ErC = 0, ErXC = 0, FPR = 0, FNR = 0, time = 0)

  # mrrr 
  family <- list(gaussian())
  start_time <- Sys.time()
  fit <- mrrr(Y, X, family = family, penstr = list(penaltySVD = "rankCon", lambdaSVD = erank))
  end_time <- Sys.time()
  Chat <- coef(fit)[-1,]
  svdXC <- svd(X %*% Chat / sqrt(n), nu = erank, nv = erank)
  Vhat <- svdXC$v
  dUhat <- Chat %*% Vhat
  dhat <- svdXC$d[1:erank]
  Uhat <- dUhat %*% diag(dhat ^ (-1))
  mrrr.fit$ErC <- est.err(C, Chat)
  mrrr.fit$ErXC <- pred.err(X, C, Chat)
  rate <- frate(U, Uhat, dhat)
  mrrr.fit$FPR <- rate$fprate
  mrrr.fit$FNR <- rate$fnrate
  mrrr.fit$time <- end_time - start_time

  if (miss == 0) {
    # srrr (D diagonal matrix, may not increase)
    start_time <- Sys.time()
    fit <- srrr(Y, X, nrank = erank, ic.type = "GIC")
    end_time <- Sys.time()
    Chat <- fit$U %*% fit$D %*% t(fit$V)
    svdXC <- svd(X %*% Chat / sqrt(n), nu = erank, nv = erank)
    Vhat <- svdXC$v
    dUhat <- Chat %*% Vhat
    dhat <- svdXC$d[1:erank]
    Uhat <- dUhat %*% diag(dhat ^ (-1))
    srrr.fit$ErC <- est.err(C, Chat)
    srrr.fit$ErXC <- pred.err(X, C, Chat)
    rate <- frate(U, Uhat, dhat)
    srrr.fit$FPR <- rate$fprate
    srrr.fit$FNR <- rate$fnrate
    srrr.fit$time <- end_time - start_time

    # seed (d is a vector)
    start_time <- Sys.time()
    fit <- seed(X, Y, nrank = erank)
    end_time <- Sys.time()
    Chat <- fit$C
    Uhat <- fit$U
    Vhat <- fit$V
    dhat <- fit$d
    seed.fit$ErC <- est.err(C, Chat)
    seed.fit$ErXC <- pred.err(X, C, Chat)
    rate <- frate(U, Uhat, dhat)
    seed.fit$FPR <- rate$fprate
    seed.fit$FNR <- rate$fnrate
    seed.fit$time <- end_time - start_time
  }

  #secure(D is diagonal matrix decrease)
  start_time <- Sys.time()
  fit <- secure.path(Y, X, nrank = erank, nlambda = 100)
  end_time <- Sys.time()
  Chat <- fit$C.est
  Uhat <- fit$U
  Vhat <- fit$V
  dhat <- diag(fit$D)
  secure.fit$ErC <- est.err(C, Chat)
  secure.fit$ErXC <- pred.err(X, C, Chat)
  rate <- frate(U, Uhat, dhat)
  secure.fit$FPR <- rate$fprate
  secure.fit$FNR <- rate$fnrate
  secure.fit$time <- end_time - start_time

  # peer (d is a vector)
  fit <- peer(X, Y, nrank = erank, penalty = "l1")
  Chat <- fit$C
  Uhat <- fit$U
  Vhat <- fit$V
  dhat <- fit$d
  peer.fit$ErC <- est.err(C, Chat)
  peer.fit$ErXC <- pred.err(X, C, Chat)
  rate <- frate(U, Uhat, dhat)
  peer.fit$FPR <- rate$fprate
  peer.fit$FNR <- rate$fnrate
  peer.fit$time <- fit$time

  if (miss == 0) {
    table <- rbind(mrrr.fit, srrr.fit, seed.fit, secure.fit, peer.fit)
    method <- c("mRRR", "SRRR", "SEED", "SeCURE", "PEER")
    table <- cbind(table, method = method)
    rownames(table) <- NULL
    return(table)
  }
  else {
    table <- rbind(mrrr.fit, secure.fit, peer.fit)
    method <- c("mRRR", "SeCURE", "PEER")
    table <- cbind(table, method = method)
    rownames(table) <- NULL
    return(table)
  }
}
